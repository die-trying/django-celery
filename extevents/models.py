import datetime
from copy import deepcopy

import pytz
import requests
from dateutil.rrule import rrulestr
from django.contrib.contenttypes.fields import GenericForeignKey
from django.contrib.contenttypes.models import ContentType
from django.db import models
from django.utils import timezone
from icalendar import Calendar

from extevents.signals import unsafe_calendar_update


class ExternalEvent(models.Model):
    """
    Represents single External event.

    src is a contentype of the source, that has generated this event,
    for example :model:`extevents.GoogleCalendar`. src should be a subsclass
    of :model:`extevents.ExternalEventSource`.

    """
    teacher = models.ForeignKey('teachers.Teacher', on_delete=models.CASCADE, related_name='busy_periods')

    src_type = models.ForeignKey(ContentType, on_delete=models.CASCADE, limit_choices_to={'app_label': 'extevents'})
    src_id = models.PositiveIntegerField()
    src = GenericForeignKey('src_type', 'src_id')

    parent = models.ForeignKey('self', null=True, blank=True)

    start = models.DateTimeField()
    end = models.DateTimeField()
    description = models.CharField(max_length=140)
    last_update = models.DateTimeField(auto_now=True)

    class Meta:
        unique_together = ('teacher', 'src_type', 'src_id', 'start', 'end')


class ExternalEventSourceManager(models.Manager):
    def active(self):
        return self.get_queryset().filter(active=True).filter(teacher__active=True)


class ExternalEventSource(models.Model):
    """
    Generic abstract class for an external events source. External events source
    may be google calendar, icloud or anything you want. Subclasses should
    implement the following two methods:
        * `poll` method that popuates the self.events list
        * Relation to :model:`teachers.Teacher`, called 'teacher'

    Generic usage:
        # Assuming that teacher is an instance of :model:`teachers.Teacher`

        for calendar in teacher.google_calendars:
            calendar.poll()  # get new events, implemented in subclass
            calendar.update()  # update event database, implemented in this class

    This will clean up previous events and store new ones, fetched
    by the model:`extevents.GoogleCalendar`.poll() method.
    """

    objects = ExternalEventSourceManager()

    url = models.URLField()
    active = models.BooleanField(default=True)
    last_update = models.DateTimeField(auto_now=True)

    events = []

    def update(self):
        """
        Clean previous stored events generated by the source and store new ones.

        Notifies support when unsafe calendar update is performed, i.e. too much events got deleted.
        """
        if not self.__is_safe():  # warn admins if calendar update is unsafe
            unsafe_calendar_update.send(sender=self.__class__, instance=self)

        self.__clear_previous_events()
        self.__save_events()

        if self.events:
            self.last_update = timezone.now()
            self.save()

    def __clear_previous_events(self):
        """
        Clear saved events where source is current instance.
        """
        self.previous_events().delete()

    def __save_events(self):
        for ev in self.events:
            ev.save()

    def previous_events(self):
        """
        A queryset, returning events with the same source, that are already in the database
        """
        return ExternalEvent.objects.filter(
            teacher=self.teacher,  # rely upon parent-class created relation
            src_id=self.pk,
            src_type=ContentType.objects.get_for_model(self),
        )

    def __is_safe(self):
        """
        Check if is it safe to update calendar event.

        For examples see extevents/tests/unit/tests_safety.py
        """
        if len(self.events) == 0 and self.previous_events().count() > 1:
            return False

        if self.previous_events().filter(parent__isnull=True).count() > 4 and self.previous_events().filter(parent__isnull=True).count() / len(self.events) > 2:
            return False

        return True

    class Meta:
        abstract = True


class GoogleCalendar(ExternalEventSource):
    EXTERNAL_EVENT_WEEK_COUNT = 8  # last all recurring events in 8 weeks to the future

    teacher = models.ForeignKey('teachers.Teacher', on_delete=models.CASCADE, related_name='google_calendars')

    def poll(self):
        """
        Fetch a calendar, then parse it and populate the `event` property with
        events from it.
        """
        try:
            res = self.fetch_calendar(self.url)
        except:
            self.events = []
        else:
            self.events = list(event for event in self.parse_events(res))

    def parse_events(self, ical_str):
        """
        Generator of events parsed from ical_str.
        """
        try:
            ical = Calendar.from_ical(ical_str)
        except:
            raise StopIteration

        yield from self.__simple_events(ical)  # first, parse all non-recurring events
        yield from self.__recurring_events(ical)  # second — generate instances of ExternalEvent for every recurring event

    def __simple_events(self, ical):
        """
        Generate non-recurring events from icalendar. Ignore events in the past.
        """
        for ev in ical.walk('VEVENT'):
            if ev.get('rrule') is None:  # rrule is a repeating rule from icalendar RFC
                event = self.parse_event(ev)

                if event.start < timezone.now():
                    continue

                yield event

    def __recurring_events(self, ical):
        """
        Generate recurring events from icalendar. Ignore events from the past except the first one.
        """
        for ev in ical.walk('VEVENT'):
            rrule = ev.get('rrule')  # rrule is a repeating rule from icalendar RFC
            if rrule is not None:
                basic_event = self.parse_event(ev)

                yield basic_event  # return basic event as the first event of the spree
                yield from self.__recurring_event_generator(rrule, basic_event)

    def __recurring_event_generator(self, rrule, basic_event):
        """
        The main generator of recuring events.
        Input — generation rule (http://icalendar.readthedocs.io/en/latest/api.html#icalendar.prop.vRecur) and the source event(:model:`extevents.ExternalEvent`).
        Output — bunch of events, starting from the next future event, ending in timedelta(weeks=self.EXTERNAL_EVENT_WEEK_COUNT)
        """
        generating_rule = "RRULE:" + rrule.to_ical().decode()  # build a string, parsable by dateutil.rrulestr, see https://dateutil.readthedocs.io/en/stable/rrule.html

        length = basic_event.end - basic_event.start  # basic length of event, apllited to all generated events

        for i in rrulestr(s=generating_rule, dtstart=basic_event.start):
            if i < timezone.now():
                continue

            if (i - timezone.now()) > datetime.timedelta(weeks=self.EXTERNAL_EVENT_WEEK_COUNT):
                raise StopIteration

            event = deepcopy(basic_event)
            event.start = i
            event.end = i + length

            event.parent = basic_event

            yield event

    def parse_event(self, event):
        """
        Return an :model:`extevents.ExternalEvent` instance built from
        an icalendar event.
        """
        (start, end) = self.__event_time(event)
        return ExternalEvent(
            start=start,
            end=end,
            description=event.get('summary'),
            teacher=self.teacher,
            src=self,
        )

    def __event_time(self, event):
        """
        Get a tuple with start and end time of event.

        All timestamps are returned in UTC.
        """
        start = event.get('dtstart').dt
        end = event.get('dtend').dt

        if isinstance(start, datetime.date) and not isinstance(start, datetime.datetime):
            """
            For single-day events we convert datetime.date objects returned
            by icalendar to datetime.datetime objects, adding '00:00' to the start time
            and '23:59' to the end time.
            """
            start = datetime.datetime.combine(start, datetime.time.min.replace(tzinfo=pytz.timezone('UTC')))  # 00:00 in UTC timezone
            end = datetime.datetime.combine(end, datetime.time.max.replace(tzinfo=pytz.timezone('UTC')))  # 23:59 in UTC timezone

        return (start, end)

    def fetch_calendar(self, url):
        r = requests.get(url, timeout=5)
        if r.status_code != 200:
            raise FileNotFoundError('Cannot fetch calendar url (%d)', r.status_code)
        return r.text
